using System;
using System.Collections.Generic;
using System.Data;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Pql.ClientDriver.Protocol;

namespace Pql.ClientDriver
{
    /// <summary>
    /// Holder for data of a single row returned or generated by PQL server. 
    /// </summary>
    public sealed class RowData
    {
        private static readonly Dictionary<DbType, Type> FieldTypeToNativeType;
        private static readonly Dictionary<DbType, DataTypeRepresentation> FieldStorage;
        private readonly byte[] m_markerBuffer;
        private readonly int[] m_fieldCountsByStorageType;
        
        /// <summary>
        /// Indexes of field values in corresponding typed arrays. 
        /// </summary>
        public readonly int[] FieldArrayIndexes;

        /// <summary>
        /// Marker, gets written before each row.
        /// </summary>
        public static readonly byte[] RowHead = new byte[] { 0xAA };

        /// <summary>
        /// Marker, gets written after the last row to indicate stream end.
        /// </summary>
        public static readonly byte[] StreamEnd = new byte[] { 0x55 };

        /// <summary>
        /// Marker, gets written before each block to indicate stream continuation.
        /// </summary>
        public static readonly byte[] BlockHead = new byte[] {0xFF};

        /// <summary>
        /// NotNulls bitvector, indexes correspond to every field's ordinal.
        /// </summary>
        public readonly int[] NotNulls;
        /// <summary>
        /// Data types, indexes correspond to every field's ordinal.
        /// </summary>
        public readonly DbType[] FieldTypes;
        /// <summary>
        /// Storage types, indexes correspond to every field's ordinal.
        /// </summary>
        public readonly DataTypeRepresentation[] FieldRepresentationTypes;
        /// <summary>
        /// Data for value types up to 8 bytes in size, indexes correspond to special mapping of field's ordinal to this array.
        /// </summary>
        public readonly ValueHolder8Bytes[] ValueData8Bytes;
        /// <summary>
        /// Data for value types from 9 to 16 bytes in size, indexes correspond to special mapping of field's ordinal to this array.
        /// </summary>
        public readonly ValueHolder16Bytes[] ValueData16Bytes;
        /// <summary>
        /// Data for string types, indexes correspond to special mapping of field's ordinal to this array.
        /// </summary>
        public readonly SizableArray<char>[] StringData;
        /// <summary>
        /// Data for binary types, indexes correspond to special mapping of field's ordinal to this array.
        /// </summary>
        public readonly SizableArray<byte>[] BinaryData;

        /// <summary>
        /// Ctr.
        /// </summary>
        /// <param name="fieldTypes">Field metadata</param>
        public RowData(DbType[] fieldTypes)
        {
            if (fieldTypes == null)
            {
                throw new ArgumentNullException("scheme");
            }

            m_markerBuffer = new byte[1];

            NotNulls = new int[BitVector.GetArrayLength(fieldTypes.Length)];

            FieldArrayIndexes = new int[fieldTypes.Length];
            FieldRepresentationTypes = new DataTypeRepresentation[fieldTypes.Length];

            m_fieldCountsByStorageType = new int[1 + Enum.GetValues(typeof(DataTypeRepresentation)).Cast<byte>().Max()];

            int count;
            for (var ordinal = 0; ordinal < fieldTypes.Length; ordinal++)
            {
                var dbType = fieldTypes[ordinal];
                var storageType = FieldStorage[dbType];
                count = m_fieldCountsByStorageType[(byte)storageType];

                FieldArrayIndexes[ordinal] = count;
                FieldRepresentationTypes[ordinal] = storageType;
                m_fieldCountsByStorageType[(byte)storageType] = count + 1;
            }

            count = m_fieldCountsByStorageType[(int) DataTypeRepresentation.Value8Bytes];
            ValueData8Bytes = count > 0 ? new ValueHolder8Bytes[count] : null;
            count = m_fieldCountsByStorageType[(int) DataTypeRepresentation.Value16Bytes];
            ValueData16Bytes = count > 0 ? new ValueHolder16Bytes[count] : null;
            count = m_fieldCountsByStorageType[(int) DataTypeRepresentation.CharArray];
            StringData = count > 0 ? new SizableArray<char>[count] : null;
            count = m_fieldCountsByStorageType[(int) DataTypeRepresentation.ByteArray];
            BinaryData = count > 0 ? new SizableArray<byte>[count] : null;

            if (StringData != null)
            {
                for (var i = 0; i < StringData.Length; i++)
                {
                    StringData[i] = new SizableArray<char>();
                }
            }

            if (BinaryData != null)
            {
                for (var i = 0; i < BinaryData.Length; i++)
                {
                    BinaryData[i] = new SizableArray<byte>();
                }
            }

            FieldTypes = fieldTypes;
        }

        /// <summary>
        /// Returns index of the field in a typed array.
        /// </summary>
        /// <param name="indexInResponse">Index of the field in the response, irrespective of its data type. Also known as Ordinal: <see cref="DataResponseField.Ordinal"/></param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetIndexInArray(int indexInResponse)
        {
            return FieldArrayIndexes[indexInResponse];
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Int64 GetInt64(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsInt64 : 0;
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Int32 GetInt32(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsInt32 : 0;
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Int16 GetInt16(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsInt16 : (Int16)0;
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Byte GetByte(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsByte : (Byte)0;
        }

        /// <summary>
        /// Returns integral value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool GetBoolean(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) && ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsBoolean;
        }

        /// <summary>
        /// Returns datetime value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DateTime GetDateTime(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsDateTime : new DateTime();
        }

        /// <summary>
        /// Returns datetime value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public DateTimeOffset GetDateTimeOffset(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData16Bytes[FieldArrayIndexes[indexInResponse]].AsDateTimeOffset : new DateTimeOffset();
        }

        /// <summary>
        /// Returns string value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string GetString(int indexInResponse)
        {
            if (BitVector.Get(NotNulls, indexInResponse))
            {
                var data = StringData[FieldArrayIndexes[indexInResponse]];
                return data.Data == null ? null : data.Data.Length == 0 ? string.Empty : new string(data.Data, 0, data.Length);
            }

            return null;
        }

        /// <summary>
        /// Returns single-character value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        /// <exception cref="DataException">String data must have exactly one character</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public char GetChar(int indexInResponse)
        {
            if (BitVector.Get(NotNulls, indexInResponse))
            {
                var data = StringData[FieldArrayIndexes[indexInResponse]];
                if (data.Length != 1)
                {
                    throw new DataException("Character array length must be equal to 1. Actual length: " + data.Length);
                }
                
                return data.Data[0];
            }

            return (char)0;
        }

        /// <summary>
        /// Reads a stream of characters from the specified column offset into the buffer as an array, starting at the given buffer offset.
        /// </summary>
        /// <returns>
        /// The actual number of characters read.
        /// </returns>
        /// <param name="i">The zero-based column ordinal. </param><param name="fieldoffset">The index within the row from which to start the read operation. </param>
        /// <param name="buffer">The buffer into which to read the stream of bytes. </param>
        /// <param name="bufferoffset">The index for <paramref name="buffer"/> to start the read operation. </param>
        /// <param name="length">The number of bytes to read. </param>
        /// <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount"/>. </exception>
        /// <filterpriority>2</filterpriority>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public long GetChars(int i, long fieldoffset, char[] buffer, int bufferoffset, int length)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (fieldoffset > int.MaxValue || fieldoffset < 0)
            {
                throw new ArgumentOutOfRangeException("fieldoffset");
            }

            if (bufferoffset > int.MaxValue || bufferoffset < 0)
            {
                throw new ArgumentOutOfRangeException("bufferoffset");
            }

            if (length <= 0)
            {
                throw new ArgumentOutOfRangeException("length");
            }

            if (BitVector.Get(NotNulls, i))
            {
                var data = StringData[FieldArrayIndexes[i]];
                int toCopy = (int)Math.Min(length, Math.Min(buffer.Length - bufferoffset, data.Length - fieldoffset));
                if (toCopy > 0)
                {
                    Buffer.BlockCopy(data.Data, sizeof(char) * (int)fieldoffset, buffer, sizeof(char) * bufferoffset, sizeof(char) * toCopy);
                    return toCopy;
                }
            }

            return 0;
        }
        
        /// <summary>
        /// Returns floating point value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double GetDouble(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsDouble : 0;
        }

        /// <summary>
        /// Returns floating point value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Single GetSingle(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsSingle : 0;
        }

        /// <summary>
        /// Returns floating point value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float GetFloat(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData8Bytes[FieldArrayIndexes[indexInResponse]].AsSingle : 0;
        }

        /// <summary>
        /// Returns guid value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Guid GetGuid(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData16Bytes[FieldArrayIndexes[indexInResponse]].AsGuid : Guid.Empty;
        }

        /// <summary>
        /// Returns binary value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte[] GetBinary(int indexInResponse)
        {
            if (BitVector.Get(NotNulls, indexInResponse))
            {
                var data = BinaryData[FieldArrayIndexes[indexInResponse]];
                var len = data.Length;
                if (len > 0)
                {
                    var result = new byte[len];
                    Buffer.BlockCopy(data.Data, 0, result, 0, len);
                    return result;
                }
                
                return null;
            }

            return null;
        }

        /// <summary>
        /// Reads a stream of bytes from the specified column offset into the buffer as an array, starting at the given buffer offset.
        /// </summary>
        /// <returns>
        /// The actual number of bytes read.
        /// </returns>
        /// <param name="i">The zero-based column ordinal. </param>
        /// <param name="fieldoffset">The index within the field from which to start the read operation. </param>
        /// <param name="buffer">The buffer into which to read the stream of bytes. </param>
        /// <param name="bufferoffset">The index for <paramref name="buffer"/> to start the read operation. </param>
        /// <param name="length">The number of bytes to read. </param>
        /// <exception cref="T:System.IndexOutOfRangeException">The index passed was outside the range of 0 through <see cref="P:System.Data.IDataRecord.FieldCount"/>. </exception>
        /// <filterpriority>2</filterpriority>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetBinary(int i, long fieldoffset, byte[] buffer, int bufferoffset, int length)
        {
            if (buffer == null)
            {
                throw new ArgumentNullException("buffer");
            }

            if (fieldoffset > int.MaxValue || fieldoffset < 0)
            {
                throw new ArgumentOutOfRangeException("fieldoffset", fieldoffset, "Invalid offset");
            }

            if (bufferoffset > int.MaxValue || bufferoffset < 0)
            {
                throw new ArgumentOutOfRangeException("bufferoffset", bufferoffset, "Invalid offset");
            }

            if (length <= 0)
            {
                throw new ArgumentOutOfRangeException("length");
            }

            if (BitVector.Get(NotNulls, i))
            {
                var data = BinaryData[FieldArrayIndexes[i]];
                int toCopy = (int)Math.Min(length, Math.Min(buffer.Length - bufferoffset, data.Length - fieldoffset));
                if (toCopy > 0)
                {
                    Buffer.BlockCopy(data.Data, (int)fieldoffset, buffer, bufferoffset, toCopy);
                    return toCopy;
                }
            }

            return 0;
        }

        /// <summary>
        /// Returns decimal value for the give field's ordinal, or default/null value if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public decimal GetCurrency(int indexInResponse)
        {
            return BitVector.Get(NotNulls, indexInResponse) ? ValueData16Bytes[FieldArrayIndexes[indexInResponse]].AsDecimal : 0;
        }

        /// <summary>
        /// Returns object-boxed value for the give field's ordinal, or null object if it is marked as null in response.
        /// </summary>
        /// <param name="indexInResponse">Field's ordinal</param>
        public object GetValue(int indexInResponse)
        {
            if (!BitVector.Get(NotNulls, indexInResponse))
            {
                return null;
            }

            var indexInArray = FieldArrayIndexes[indexInResponse];
            switch (FieldTypes[indexInResponse])
            {
                //case DbType.VarNumeric:
                //    break;
                case DbType.Object:
                case DbType.Binary:
                    return GetBinary(indexInResponse);
                case DbType.SByte:
                    return ValueData8Bytes[indexInArray].AsSByte;
                case DbType.Byte:
                    return ValueData8Bytes[indexInArray].AsByte;
                case DbType.Boolean:
                    return ValueData8Bytes[indexInArray].AsBoolean;
                case DbType.Decimal:
                case DbType.Currency:
                    return ValueData16Bytes[indexInArray].AsDecimal;
                case DbType.Double:
                    return ValueData8Bytes[indexInArray].AsDouble;
                case DbType.Guid:
                    return GetGuid(indexInResponse);
                case DbType.Int16:
                    return ValueData8Bytes[indexInArray].AsInt16;
                case DbType.UInt16:
                    return ValueData8Bytes[indexInArray].AsUInt16;
                case DbType.Int32:
                    return ValueData8Bytes[indexInArray].AsInt32;
                case DbType.UInt32:
                    return ValueData8Bytes[indexInArray].AsUInt32;
                case DbType.Date:
                case DbType.DateTime:
                case DbType.DateTime2:
                    return ValueData8Bytes[indexInArray].AsDateTime;
                case DbType.Time:
                    return ValueData8Bytes[indexInArray].AsTimeSpan;
                case DbType.DateTimeOffset:
                    return ValueData16Bytes[indexInArray].AsDateTimeOffset;
                case DbType.Int64:
                    return ValueData8Bytes[indexInArray].AsInt64;
                case DbType.UInt64:
                    return ValueData8Bytes[indexInArray].AsUInt64;
                case DbType.Single:
                    return ValueData8Bytes[indexInArray].AsSingle;
                case DbType.String:
                case DbType.AnsiString:
                case DbType.AnsiStringFixedLength:
                case DbType.StringFixedLength:
                case DbType.Xml:
                    return GetString(indexInResponse);
                default:
                    throw new DataException("Invalid DbType: " + FieldTypes[indexInResponse]);
            }
        }

        /// <summary>
        /// Returns array of object values, as many as can fit in <paramref name="values"/>.
        /// </summary>
        /// <param name="values">Destination array</param>
        /// <returns>Number of values written to array</returns>
        public int GetValues(object[] values)
        {
            if (values == null || values.Length == 0)
            {
                return 0;
            }

            var toCopy = Math.Min(values.Length, FieldArrayIndexes.Length);
            for (var i = 0; i < toCopy; i++)
            {
                values[i] = GetValue(i);
            }

            return toCopy;
        }

        /// <summary>
        /// Attempts to read next row from the data stream.  
        /// </summary>
        /// <returns>True is successful and row data is available for retrieval with Getxxx methods. False otherwise.</returns> 
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Read(BinaryReader reader)
        {
            if (!CheckRowAvailable(reader))
            {
                Clear();
                return false;
            }

            BitVector.Read(NotNulls, FieldTypes.Length, reader);

            for (var indexInResponse = 0; indexInResponse < FieldArrayIndexes.Length; indexInResponse++)
            {
                if (!BitVector.Get(NotNulls, indexInResponse))
                {
                    continue;
                }

                var indexInArray = FieldArrayIndexes[indexInResponse];
                switch (FieldTypes[indexInResponse])
                {
                    //case DbType.VarNumeric:
                    //    break;
                    case DbType.Object:
                    case DbType.Binary:
                        {
                            var data = BinaryData[indexInArray];
                            data.SetLength(Read7BitEncodedInt(reader));
                            var bytesRead = 0;
                            while (bytesRead < data.Length)
                            {
                                var count = reader.Read(data.Data, bytesRead, data.Length - bytesRead);
                                if (count == 0)
                                {
                                    throw new DataException("Unexpected end of stream");
                                }
                                bytesRead += count;
                            }
                        }
                        break;
                    case DbType.SByte:
                    case DbType.Byte:
                        ValueData8Bytes[indexInArray].AsByte = reader.ReadByte();
                        break;
                    case DbType.Boolean:
                        ValueData8Bytes[indexInArray].AsBoolean = reader.ReadBoolean();
                        break;
                    case DbType.Decimal:
                    case DbType.Currency:
                    case DbType.Guid:
                    case DbType.DateTimeOffset:
                        ValueData16Bytes[indexInArray].Lo = reader.ReadInt64();
                        ValueData16Bytes[indexInArray].Hi = reader.ReadInt64();
                        break;
                    case DbType.Int16:
                    case DbType.UInt16:
                        ValueData8Bytes[indexInArray].AsInt16 = reader.ReadInt16();
                        break;
                    case DbType.Int32:
                    case DbType.UInt32:
                    case DbType.Single:
                        ValueData8Bytes[indexInArray].AsInt32 = reader.ReadInt32();
                        break;
                    case DbType.Date:
                    case DbType.DateTime:
                    case DbType.DateTime2:
                    case DbType.Time:
                    case DbType.Int64:
                    case DbType.UInt64:
                    case DbType.Double:
                        ValueData8Bytes[indexInArray].AsInt64 = reader.ReadInt64();
                        break;
                    case DbType.String:
                    case DbType.AnsiString:
                    case DbType.AnsiStringFixedLength:
                    case DbType.StringFixedLength:
                    case DbType.Xml:
                        {
                            var data = StringData[indexInArray];
                            var len = Read7BitEncodedInt(reader);
                            data.SetLength(len);
                            for (var i = 0; i < len; i++)
                            {
                                data.Data[i] = (char) Read7BitEncodedInt(reader);
                            }
                        }
                        break;
                    default:
                        throw new DataException("Invalid DbType: " + FieldTypes[indexInResponse]);
                }
            }

            return true;
        }

        /// <summary>
        /// Writes row data into output stream.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Write(BinaryWriter writer)
        {
            WriteRowHeader(writer);

            BitVector.Write(NotNulls, FieldTypes.Length, writer);

            for (var indexInResponse = 0; indexInResponse < FieldArrayIndexes.Length; indexInResponse++)
            {
                if (!BitVector.Get(NotNulls, indexInResponse))
                {
                    continue;
                }

                var indexInArray = FieldArrayIndexes[indexInResponse];

                switch (FieldTypes[indexInResponse])
                {
                        //case DbType.VarNumeric:
                        //    break;
                    case DbType.Object:
                    case DbType.Binary:
                        {
                            var data = BinaryData[indexInArray];
                            var len = data.Length;
                            Write7BitEncodedInt(writer, len);
                            if (len > 0)
                            {
                                writer.Write(data.Data, 0, data.Length);
                            }
                        }
                        break;
                    case DbType.SByte:
                    case DbType.Byte:
                        writer.Write(ValueData8Bytes[indexInArray].AsByte);
                        break;
                    case DbType.Boolean:
                        writer.Write(ValueData8Bytes[indexInArray].AsBoolean);
                        break;
                    case DbType.Decimal:
                    case DbType.Currency:
                    case DbType.Guid:
                    case DbType.DateTimeOffset:
                        writer.Write(ValueData16Bytes[indexInArray].Lo);
                        writer.Write(ValueData16Bytes[indexInArray].Hi);
                        break;
                    case DbType.Int16:
                    case DbType.UInt16:
                        writer.Write(ValueData8Bytes[indexInArray].AsInt16);
                        break;
                    case DbType.Int32:
                    case DbType.UInt32:
                    case DbType.Single:
                        writer.Write(ValueData8Bytes[indexInArray].AsInt32);
                        break;
                    case DbType.Date:
                    case DbType.DateTime:
                    case DbType.DateTime2:
                    case DbType.Time:
                    case DbType.Int64:
                    case DbType.UInt64:
                    case DbType.Double:
                        writer.Write(ValueData8Bytes[indexInArray].AsInt64);
                        break;
                    case DbType.String:
                    case DbType.AnsiString:
                    case DbType.AnsiStringFixedLength:
                    case DbType.StringFixedLength:
                    case DbType.Xml:
                        {
                            var data = StringData[indexInArray];
                            Write7BitEncodedInt(writer, data.Length);
                            for (var i = 0; i < data.Length; i++)
                            {
                                Write7BitEncodedInt(writer, data.Data[i]);
                            }
                        }
                        break;
                    default:
                        throw new DataException("Invalid DbType: " + FieldTypes[indexInResponse]);
                }
            }
        }

        /// <summary>
        /// Returns minimum byte count that call to <see cref="Write"/> will generate.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetMinimumSize()
        {
            return RowHead.Length + NotNulls.Length * sizeof (Int32);
        }

        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Clear()
        {
            if (ValueData8Bytes != null)
            {
                Array.Clear(ValueData8Bytes, 0, ValueData8Bytes.Length);
            }

            if (ValueData16Bytes != null)
            {
                Array.Clear(ValueData16Bytes, 0, ValueData16Bytes.Length);
            }

            if (StringData != null)
            {
                foreach (var item in StringData)
                {
                    item.SetLength(0);
                }
            }

            if (BinaryData != null)
            {
                foreach (var item in BinaryData)
                {
                    item.SetLength(0);
                }
            }
        }

        static RowData()
        {
            FieldStorage = new Dictionary<DbType, DataTypeRepresentation>
                {
                    {DbType.AnsiString, DataTypeRepresentation.CharArray},
                    {DbType.AnsiStringFixedLength, DataTypeRepresentation.CharArray},
                    {DbType.Binary, DataTypeRepresentation.ByteArray},
                    {DbType.Object, DataTypeRepresentation.ByteArray},
                    {DbType.Boolean, DataTypeRepresentation.Value8Bytes},
                    {DbType.Byte, DataTypeRepresentation.Value8Bytes},
                    {DbType.Currency, DataTypeRepresentation.Value16Bytes},
                    {DbType.Date, DataTypeRepresentation.Value8Bytes},
                    {DbType.DateTime, DataTypeRepresentation.Value8Bytes},
                    {DbType.DateTime2, DataTypeRepresentation.Value8Bytes},
                    {DbType.DateTimeOffset, DataTypeRepresentation.Value16Bytes},
                    {DbType.Decimal, DataTypeRepresentation.Value16Bytes},
                    {DbType.Double, DataTypeRepresentation.Value8Bytes},
                    {DbType.Guid, DataTypeRepresentation.Value16Bytes},
                    {DbType.Int16, DataTypeRepresentation.Value8Bytes},
                    {DbType.Int32,DataTypeRepresentation.Value8Bytes},
                    {DbType.Int64, DataTypeRepresentation.Value8Bytes},
                    {DbType.SByte, DataTypeRepresentation.Value8Bytes},
                    {DbType.Single, DataTypeRepresentation.Value8Bytes},
                    {DbType.String, DataTypeRepresentation.CharArray},
                    {DbType.StringFixedLength, DataTypeRepresentation.CharArray},
                    {DbType.Time, DataTypeRepresentation.Value8Bytes},
                    {DbType.UInt16, DataTypeRepresentation.Value8Bytes},
                    {DbType.UInt32, DataTypeRepresentation.Value8Bytes},
                    {DbType.UInt64, DataTypeRepresentation.Value8Bytes},
                    {DbType.Xml, DataTypeRepresentation.CharArray}
                };

            //FieldTypes.Add(DbType.VarNumeric, null);
            FieldTypeToNativeType = new Dictionary<DbType, Type>
                {
                    {DbType.AnsiString, typeof (String)},
                    {DbType.AnsiStringFixedLength, typeof (String)},
                    {DbType.Binary, typeof (Byte[])},
                    {DbType.Object, typeof (Byte[])},
                    {DbType.Boolean, typeof (Boolean)},
                    {DbType.Byte, typeof (Byte)},
                    {DbType.Currency, typeof (Decimal)},
                    {DbType.Date, typeof (DateTime)},
                    {DbType.DateTime, typeof (DateTime)},
                    {DbType.DateTime2, typeof (DateTime)},
                    {DbType.DateTimeOffset, typeof (DateTimeOffset)},
                    {DbType.Decimal, typeof (Decimal)},
                    {DbType.Double, typeof (Double)},
                    {DbType.Guid, typeof (Guid)},
                    {DbType.Int16, typeof (Int16)},
                    {DbType.Int32, typeof (Int32)},
                    {DbType.Int64, typeof (Int64)},
                    {DbType.SByte, typeof (SByte)},
                    {DbType.Single, typeof (Single)},
                    {DbType.String, typeof (String)},
                    {DbType.StringFixedLength, typeof (String)},
                    {DbType.Time, typeof (TimeSpan)},
                    {DbType.UInt16, typeof (UInt16)},
                    {DbType.UInt32, typeof (UInt32)},
                    {DbType.UInt64, typeof (UInt64)},
                    {DbType.Xml, typeof (String)}
                };
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool CheckRowAvailable(BinaryReader reader)
        {
            byte rowHead;
            try
            {
                if (0 == reader.Read(m_markerBuffer, 0, 1))
                {
                    return false;
                }
                rowHead = m_markerBuffer[0];
            }
            catch (EndOfStreamException)
            {
                return false;
            }

            if (rowHead == StreamEnd[0])
            {
                return false;
            }

            if (rowHead != RowHead[0])
            {
                throw new DataException("Invalid row header byte in input stream: " + rowHead);
            }
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static void WriteRowHeader(BinaryWriter writer)
        {
            writer.Write(RowHead);
        }

        /// <summary>
        /// Disassembled method from BinaryReader.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Read7BitEncodedInt(BinaryReader reader)
        {
            int num1 = 0;
            int num2 = 0;
            while (num2 != 35)
            {
                byte num3 = reader.ReadByte();
                num1 |= ((int)num3 & (int)sbyte.MaxValue) << num2;
                num2 += 7;
                if (((int)num3 & 128) == 0)
                    return num1;
            }
            throw new FormatException("Bad 7Bit-encoded Int32");
        }

        /// <summary>
        /// Disassembled method from BinaryWriter.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void Write7BitEncodedInt(BinaryWriter writer, int value)
        {
            uint num = (uint)value;
            while (num >= 128U)
            {
                writer.Write((byte)(num | 128U));
                num >>= 7;
            }
            writer.Write((byte)num);
        }

        /// <summary>
        /// In-memory representation.
        /// </summary>
        public enum DataTypeRepresentation : byte
        {
            /// <summary>
            /// Array of bytes
            /// </summary>
            ByteArray,
            /// <summary>
            /// Array of chars (two-byte Unicode chars)
            /// </summary>
            CharArray,
            /// <summary>
            /// Uses <see cref="ValueHolder8Bytes"/>
            /// </summary>
            Value8Bytes,
            /// <summary>
            /// Uses <see cref="ValueHolder16Bytes"/>
            /// </summary>
            Value16Bytes
        }

        /// <summary>
        /// Universal value holder. Temporary, to reduce complexity.
        /// </summary>
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public struct ValueHolder8Bytes
        {
            /// <summary>
            /// Boolean value.
            /// </summary>
            [FieldOffset(0)]
            public Boolean AsBoolean;

            /// <summary>
            /// Byte value.
            /// </summary>
            [FieldOffset(0)]
            public Byte AsByte;

            /// <summary>
            /// signed byte value.
            /// </summary>
            [FieldOffset(0)]
            public SByte AsSByte;

            /// <summary>
            /// Int64 value.
            /// </summary>
            [FieldOffset(0)]
            public Int64 AsInt64;

            /// <summary>
            /// Unsigned Int64 value.
            /// </summary>
            [FieldOffset(0)]
            public UInt64 AsUInt64;

            /// <summary>
            /// Int16 value.
            /// </summary>
            [FieldOffset(0)]
            public Int16 AsInt16;

            /// <summary>
            /// Unsigned Int16 value.
            /// </summary>
            [FieldOffset(0)]
            public UInt16 AsUInt16;

            /// <summary>
            /// Int32 value.
            /// </summary>
            [FieldOffset(0)]
            public Int32 AsInt32;

            /// <summary>
            /// Unsigned Int32 value.
            /// </summary>
            [FieldOffset(0)]
            public UInt32 AsUInt32;

            /// <summary>
            /// Double (64bit) floating point value.
            /// </summary>
            [FieldOffset(0)]
            public Double AsDouble;

            /// <summary>
            /// Single (32bit) floating point value.
            /// </summary>
            [FieldOffset(0)]
            public Single AsSingle;

            /// <summary>
            /// DateTime (64bit) value.
            /// </summary>
            [FieldOffset(0)]
            public DateTime AsDateTime;

            /// <summary>
            /// TimeSpan (64bit) value.
            /// </summary>
            [FieldOffset(0)]
            public TimeSpan AsTimeSpan;
        }

        /// <summary>
        /// Universal value holder. Temporary, to reduce complexity.
        /// </summary>
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public struct ValueHolder16Bytes
        {
            /// <summary>
            /// Raw data.
            /// </summary>
            [FieldOffset(0)]
            public Int64 Lo;

            /// <summary>
            /// Raw data.
            /// </summary>
            [FieldOffset(8)]
            public Int64 Hi;

            /// <summary>
            /// Decimal-currency (128bit) value.
            /// </summary>
            [FieldOffset(0)]
            public Decimal AsDecimal;

            /// <summary>
            /// Guid (128bit) value.
            /// </summary>
            [FieldOffset(0)]
            public Guid AsGuid;

            /// <summary>
            /// DateTimeOffset (80bit) value.
            /// </summary>
            [FieldOffset(0)]
            public DateTimeOffset AsDateTimeOffset;
        }

        /// <summary>
        /// Attempts to find a system type based on provided logical data type.
        /// </summary>
        /// <param name="dbType">Logical data type</param>
        /// <returns>System type</returns>
        /// <exception cref="ArgumentOutOfRangeException">Unknown data type</exception>
        public static Type DeriveSystemType(DbType dbType)
        {
            if (!FieldTypeToNativeType.TryGetValue(dbType, out var result))
            {
                throw new ArgumentOutOfRangeException("dbType", dbType, "Unknown data type");
            }

            return result;
        }
    }
}